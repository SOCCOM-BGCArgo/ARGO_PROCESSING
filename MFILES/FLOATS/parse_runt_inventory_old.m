function d = parse_runt_inventory(save_path, url)
%
% PURPOSE:
%    This function saves a local copy of an Iventory list generated by
%    Dana Swift as a text file and then parses the text file and save the
%    data in a structure. Parseing is brute force because the file format
%    changes! The inteded use is to use the cell array as a lookup table to
%    match APEX ID with MSC number
%
% INPUTS:
%    url - a url to an inventory list
%          Example = ['http://runt.ocean.washington.edu/swift/', ...
%                     'Argo2018Logistics/TposInventory.mbari'];
%
%   save_path - path to save web grab to
%          Example 'C:\temp'
%
% OUTPUTS:
%    hdr - a cell arrayt describing column titles
% 
%    data - a cell array of data
%
%    info.url - target url
%    info.local - local target to save data to
%
% USE EXAMPLE:
%    url = 'http://runt.ocean.washington.edu/swift/Argo2018Logistics/TposInventory.mbari';
%    save_path = 'C:\temp\'
%    d = parse_runt_inventory(save_path, url)


% ************************************************************************
% DO SOME PREP WORK, GET FILE FROM URL
d = []; % defult function return
master_hdr ={'WrcId' 'ApfId' 'NpfId' 'SbeId' 'MscId' 'OptodeId' , ...
             'FlbbId' 'PalId' 'DeploymentOpportunity'};
out        = cell(100, size(master_hdr,2)); % predim output

yr = 'XXXX';
yr      = regexp(url,'(?<=Argo)\d+','once','match');
fn      = regexp(url,'(?<=Logistics/)\S+','once','match');
save_fn = [yr,fn,'.TXT'];
save_fp = fullfile(save_path, save_fn);



try
    websave(save_fp, url);
catch
    disp('WARNING: URL destination could not be accessed!');
    disp('Check inputs:');
    disp(['local target: ',save_path]);
    disp(['URL target: ',url]);
    return
end

% ************************************************************************
% PARSE FILE SAVED LOCALLY
fid = fopen(save_fp);

% LOOP THROUGH LINES & STOP AT HEADERS THEN LOOK FOR DATA LINES
% Format is variable so use brute force. Use header to get fixed width
% formating. Since line size varies the last width will be dewtermined on
% the fly & line by line
tf_inv = 0;
tline = ' ';
line_ct = 1;
while ischar(tline)
    if regexp(tline,'^\s+# WrcId','once') & ...
            regexp(tline,'MscId|IsusId','once')% Header line with MSC col found
        tf_inv     = 1; % Processing swith
        hdr_line   = regexprep(tline,'#',' '); % replace "#' with " " for parsing ease
        hdr_line   = regexprep(hdr_line,'IsusId',' MscId'); % early MSC col was IsusId
        end_inds   = regexp(hdr_line,'\S+', 'end'); 
        end_inds   = end_inds(1:end-1); % last ending size will be variable
        start_inds = end_inds +1;
        start_inds = [1, start_inds]; % 1 more than  end inds now
        hdr        = regexp(strtrim(hdr_line),'\s+', 'split');
        
        % GET MASTER HEADER INDICES TO ASSIGN INVENTORY DATA LINE ENTRIES TO MASTER
        % HEADER COLUMNS
        dcol_inds = ones(size(hdr))* NaN; 
        for i = 1:size(hdr,2)
            ind = find(strcmp(master_hdr, hdr{i}) == 1);
            if ~isempty(ind)
                dcol_inds(i) = ind;
            end
        end
        
        disp(tline)
    elseif regexp(tline,'^\s+# WrcId','once') % non MSC header line turn off suearch
        tf_inv = 0;
    end
    
    % Parse a data line
    if tf_inv ==1 & regexp(tline,'^\s{0,10}\d+','once') % inventory data line 
        disp(tline)
        end_inds2 = [end_inds, size(tline,2)]; % varible size lines so and last on the fly
        for i = 1:size(hdr,2)
            out{line_ct, dcol_inds(i)} = strtrim(tline(start_inds(i):end_inds2(i)));
        end
        line_ct = line_ct + 1;     
    end
    
    tline = fgetl(fid);
end
fclose(fid);
out = out(1:line_ct-1,:);

% ASSIGN OUTPUTS
d.hdr        = master_hdr;
d.data       = out;
d.info.url   = url;
d.info.local = save_path;

clearvars -except d



